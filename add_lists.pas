{$mode TP}
{$codepage UTF-8}
{$R+,B+,X-}

// ---------------------------------------------------------------------
// Выход-9 (от 15.12.2022)   
// "СУММИРОВАНИЕ ДЛИННЫХ ЧИСЕЛ" (120 очков)
// РЕШАТЬ САМОСТОЯТЕЛЬНО, А НЕ КОЛЛЕКТИВНО (КАЖДЫЙ РАБОТАЕТ НА СЕБЯ !)
// ---------------------------------------------------------------------
// НЕ ДОПУСКАТЬ УТЕЧКИ ПАМЯТИ, СДАВАЯ все ЭТАПЫ.                     
(***********************************************************************
                        ПОСТАНОВКА ЗАДАЧИ
************************************************************************
Дан внешний (НЕПУСТОЙ) текстовый файл с именем numbers.txt, в каждой
строке которого записано ровно ОДНО целое НЕОТРИЦАТЕЛЬНОЕ число 
ПРОИЗВОЛЬНОЙ ДЛИНЫ (гарантируется, что в строке нет пробелов и иных 
символов, не относящихся к числу, и что это число записано без знака +
и без незначащих нулей). 
Программа должна вывести на экран СУММУ этих чисел. Например, 
если файл numbers.txt имел вид:
___________
209
0
9876543000
1
___________
то на экране должно быть напечатано число 9876543210
(т.к. 209 + 0 + 9876543000 + 1 = 9876543210)

ОГРАНИЧЕНИЯ в решении: 
1) ЗАПРЕЩЕНО использовать массивы;  
2) для считывания цифр числа следует использовать ТОЛЬКО СИМВОЛЬНЫЙ ВВОД
   вида read(t, c), где t – текстовый файл, c – символьная переменная;
3) числа (т.е. строки файла) можно просматривать ТОЛЬКО ОДИН РАЗ;

ТЕСТЫ, на которых будет проверяться работа программы, см. в самом конце.
************************************************************************
                      ИДЕЯ решения задачи
************************************************************************
Каждое ЧИСЛО (записанное в отдельной строке текстового файла) следует 
считывать ПОСИМВОЛЬНО и представлять в виде линейного СПИСКА, в котором
ЦИФРЫ этого числа будут располагаться в ОБРАТНОМ порядке (от младшей 
цифры к старшей) для того, чтобы осуществлять СУММИРОВАНИЕ ЧИСЕЛ путем 
сложения их ЦИФР, начиная с младших разрядов, с переходом к более старшим 
разрядам (учитывая возможность ПЕРЕНОСА ЕДИНИЦЫ в более старший разряд).     
************************************************************************
ЭТАП_1   Работа в цикле (по СТРОКАМ текстового файла)    (50 очков)
Шаг цикла: построение СПИСКА требуемого вида по каждому прочитанному 
ЧИСЛУ (записанному в очередной СТРОКЕ файла), вывод этого числа на экран 
(используя полученный список) и последующее удаление списка 
(с освобождением памяти).
------------------------------------------------------------------------
ТРЕБОВАНИЯ к решению ЭТАПА_1: 
1) Описать функцию CreateList(t), которая по текущей строке текстового 
   файла t (хранящей очередное число) строит список требуемого вида 
   и возвращает ссылку на построенный список.
   Подсказка - список следует строить ОТ КОНЦА К НАЧАЛУ. В отдельных 
   звеньях должны располагаться цифры (как integer, а не char) 
   прочитанного числа, начиная с самых младших цифр. 
   Примеры представления списков для различных чисел:
   Число 209: (9,0,2)
   Число 0: (0)
   Число 9876543000: (0,0,0,3,4,5,6,7,8,9)
   Число 1: (1)
2) Ссылку на построенный список следует присвоить переменной L, 
   описанной в основной программе.
3) Распечатать получившийся список, описав предварительно процедуру  
   вывода элементов списка Print(L) так, чтобы на экране вывелось
   соответстующее число в нормальном (неперевернутом) виде.
   Совет: процедуру Print(L) удобно описывать рекурсивно.
4) Удалить список L (с освобождением памяти) после распечатывания 
   цифр очередного числа, описав соответствующую процедуру Destroy(L).
5) Процедуры CreateList(t), Print(L) и Destroy(L) вызывать из 
   раздела операторов основной программы.
------------------------------------------------------------------------
ЭТАП_2 Сложение прочитанных чисел и вывод результата на экран (70 очков)
За один просмотр каждого из полученных списков-чисел, сформировать 
результирующий список S, представляющий сумму этих чисел (цифры 
результата в списке  S должны располагаться от младших к старшим).
------------------------------------------------------------------------
ТРЕБОВАНИЯ к решению ЭТАПА_2: 
1) Описать процедуру  Add(S, L) для сложения двух чисел, 
   представленных списками S и L, которая формирует получившуюся 
   сумму в списке S путем изменения значений его звеньев.
2) Применить процедуру Add(S, L) для сложения всех чисел из файла: 
   в цикле в разделе операторов основной программы, накапливая сумму 
   в списке S (для этого в начале программы следует инициализировать 
   список S как список, представляющий число 0).
3) Процедура Add(S, L) должна параллельно проходить по списку S 
   (в котором накапливается результат суммирования) и списку L
   (который получен после считывания строки с очередным числом) 
   ровно ОДИН раз.
4) После сложения всех чисел вывести на экран полученный ответ 
   (сформированный в списке S), воспользовавшись ранее написанной 
   процедурой Print(L), после чего удалить список S 
   (с освобождением памяти).

ПОДСКАЗКА по реализации функции Add(S, L): 
1) просматривать списки от начала в конец с помощью вспомогательных
   указателей, осуществляя суммирование  чисел путем сложения их 
   цифр, начиная с младших разрядов и переходя к старшим с учетом
   переноса единицы в следующий разряд.
2) воспользоваться тем фактом, что списки-параметры не могут быть 
   пустыми (так как числа содержат хотя бы одну цифру), и сначала 
   сложить первые цифры чисел, а потом складывать цифры из звеньев, 
   на которые указывает поле next текущего звена.
3) для вставки новой цифры в конец результирующего списка также
   воспользоваться этим фактом, модифицруя поле next текущего звена.
***********************************************************************)
program task(input, output);
uses heaptrc;        {подключение модуля контроля утечки памяти}
type
    TE = integer;    {для удобства суммирования чисел-списков на 2 этапе}
    list = ^node;
    node = record
        elem: TE;
        next: list
    end;
var 
    L: list;         {список, который следует строить построчно}
    S: list;         {список, в котором формируется представление суммы}
    t: text;         {текстовый файл: в каждой строке ровно одно число}
    
//////////////////////////////////////////////////////////////////////
////   далее располагаются описания ваших процедур и функций      ////
//////////////////////////////////////////////////////////////////////

function CreateList(var t: text): list;
var
    p: list;
    c: char;
begin
    L := nil;
    while not eoln(t) do begin
        read(t, c);
        new(p);
        p^.elem := ord(c) - ord('0');
        p^.next := L;
        L := p;
    end;
    readln(t);
    CreateList := L;
end;

procedure Print(L: list);
begin
    if L^.next <> nil then begin
        Print(L^.next);
        write(L^.elem);
    end
    else
        write(L^.elem);
end;

procedure Destroy(var L: list);
var
    p: list;
begin
    if L <> nil then begin
        p := L;
        L := L^.next;
        dispose(p);
        destroy(L);
    end;
end;

procedure Add(S: list; L: list);
var
    p, pt: list;
    t: integer;
begin
    pt := S;
    while L <> nil do begin
        t := (pt^.elem + L^.elem) div 10;
        pt^.elem := (pt^.elem + L^.elem) mod 10;
        if L^.next <> nil then begin
            if pt^.next <> nil then begin
                pt := pt^.next;
                pt^.elem := t + pt^.elem;
            end
            else begin
                new(p);
                p^.elem := t;
                p^.next := nil;
                pt^.next := p;
                pt := p;
            end;
        end
        else begin // если считали последнее число из файла
            while pt^.next <> nil do begin
                pt := pt^.next;
                pt^.elem := t + pt^.elem;
                t := pt^.elem div 10;
                pt^.elem := pt^.elem mod 10;
            end;
            if (t > 0) and (pt^.next = nil) then begin
                new(p);
                p^.elem := t;
                p^.next := nil;
                pt^.next := p;
                pt := p;
            end;
        end;
        L := L^.next;
    end;
end;

begin
    {содержимое раздела операторов - менять с учётом сдаваемых этапов}
    writeln('-----------------------------');
    writeln('work-9 "Summing long numbers"');
    writeln('-----------------------------');    

    assign(t, 'numbers.txt');            {нужно для Фри-Паскаля}
    reset(t);
    
    {инициализация списка S (в котором формируется искомая сумма чисел):}
    new(S);                         {подключить при сдаче ЭТАПА_2}
    S^.elem := 0;                   {подключить при сдаче ЭТАПА_2}
    S^.next := nil;                 {подключить при сдаче ЭТАПА_2}
    
    {цикл по строкам текстового файла, в каждой строке ровно одно число:}
    while not eof(t) do begin
        L := CreateList(t);
        write('Next number: ');
        Print(L);
        writeln;
        Add(S, L);                  {подключить при сдаче ЭТАПА_2}
        Destroy(L);
        write('Current sum: ');      {подключить при сдаче ЭТАПА_2}
        Print(S);                    {подключить при сдаче ЭТАПА_2}       
        writeln;                     {подключить при сдаче ЭТАПА_2}
        writeln                      {подключить при сдаче ЭТАПА_2}
    end;
    write('Result sum: ');          {подключить при сдаче ЭТАПА_2}
    Print(S);                       {подключить при сдаче ЭТАПА_2}
    Destroy(S);                     {подключить при сдаче ЭТАПА_2}
  
    close(t);                          {нужно для Фри-Паскаля}   
    writeln;
    reset(t)
end.

{
------------------------------------------------------------------------
                                ТЕСТЫ
------------------------------------------------------------------------
Тест_1:
------------------------------------------------------------------------
209
0
9876543000
1

ПОСЛЕ ЭТАПА_1:
209
0
9876543000
1

ПОСЛЕ ЭТАПА_2:
9876543210
------------------------------------------------------------------------
Тест_2:
------------------------------------------------------------------------
1

ПОСЛЕ ЭТАПА_1:
1

ПОСЛЕ ЭТАПА_2:
1
------------------------------------------------------------------------
Тест_3:
------------------------------------------------------------------------
1
999

ПОСЛЕ ЭТАПА_1:
1
999

ПОСЛЕ ЭТАПА_2:
1000
------------------------------------------------------------------------
Тест_4:
------------------------------------------------------------------------
999
1

ПОСЛЕ ЭТАПА_1:
999
1

ПОСЛЕ ЭТАПА_2:
1000
------------------------------------------------------------------------
Тест_5:
------------------------------------------------------------------------
9
11122233444555666777888999
998877665544332211
999988887777666655554444333322221111
998877665544332211
123456789
12345


ПОСЛЕ ЭТАПА_1:
9
11122233444555666777888999
998877665544332211
999988887777666655554444333322221111
998877665544332211
123456789
12345

ПОСЛЕ ЭТАПА_2:
999988887788788890996755331312243675
}
